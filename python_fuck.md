# `可变对象`当做函数的默认参数
在python语言，无论默认参数所指向的是**可变**还是**不可变对象**，都要遵守下面的参数规则。
- 每一条def函数定义语句，都会创建一个函数对象，而且函数的默认参数求值也只会执行这一次
- 函数无论被调用多少次，**默认参数指向的地址还是函数定义时赋予的地址，不会改变**；
- 即使在函数内，默认参数被重新赋值，指向了另一个新对象，下一次这个函数被调用，**默认参数使用的还是函数定义时赋予的地址**，并不会使用改变后的地址/对象。 因为，函数头的默认参数只求值一次，并且是作为函数对象的一部分一起被保存起来，每次函数被调用，都是从这个函数对象获取函数头信息。除非再次碰到def函数定义语句，那么理所当然的就会重新创建另一个新的函数对象，这时默认参数才会再次被重新求值。

### 和预期不同：`可变对象的默认参数`值是累加的，不再是初始化的值
```python
def bad_append(new_item, a_list=[]):
    print('address of a_list:', id(a_list))
    a_list.append(new_item)
    return a_list

print(bad_append('1'))  # 两次调用bad_append，默认参数a_list的地址是相同的。
print(bad_append('2'))
```
输出：
```
address of a_list: 4344363776
['1']
address of a_list: 4344363776
['1', '2']
```
从上面的例子也可以看出，两次调用`bad_append`，默认参数`a_list`的地址是相同的，也就是说都是**同一对象**，默认参数使用的还是函数定义时赋予的地址， 但是： 该地址指向的是一个可**变对象**，而且这个可变对象的值已经在函数体内被改变了， 所以再次调用该函数， 结果就是： **可变对象的默认参数的值是累加的，而不再是初始化值了**。
  
- 根源在于 Python 是动态语言，以关键字 `def` 开头的函数定义在 Python中也是个可执行语句。每碰到一条`def`定义的函数，这条语句就会被执行，而且就像定义其它普通变量一样，这条语句仅且执行一次；并且执行的是 **`函数头`里默认参数的赋值语句**和函数名称和这个函数对象的绑定，并将参数保存为函数对象的一部分（即其属性）。之后通过该函数名称进行函数调用的时候，只会执行函数体（通过 `__code__ `指向的代码片段）的语句， 函数头里的东西不会再次执行。结论：函数无论被调用多少次，**默认参数指向的地址还是函数定义时赋予的地址，不会改变**；<br><br>
  
- 而在函数不是第一等公民静态语言中，函数定义是在编译阶段做的，不能在运行时多次重复绑定。在每次函数调用时，形参实参都会进行一次结合。 结论：就是默认参数在函数被调用的时候，默认参数都会被重新赋予默认值。

再看看下面这个例子
```python
import datetime as dt
from time import sleep

def log_time(msg, the_time=dt.datetime.now()):
    sleep(1)  # 线程暂停一秒
    print(the_time, msg)

log_time('msg 1')  # 2023-07-28 18:59:45.085270 msg 1
log_time('msg 2')  # 2023-07-28 18:59:45.085270 msg 2
log_time('msg 3')  # 2023-07-28 18:59:45.085270 msg 3
```
即使使用了sleep(1)让线程暂停一秒，排除了程序执行很快的因素。输出中三次调用打印出的时间还是相同的，即三次调用中默认参数the_time的值是相同的。

### 符合预期：`不可变对象的默认参数`，每次调用使用的都是初始化的值。

根据默认参数的规则，**函数无论调用多少次，默认参数指向的地址还是函数定义时赋予的地址**（也就是def定义函数，默认参数求值时的地址）。 在下面的例子中默认参数i指向的地址的值还是1，并没有被改变。 结论：不可变对象的默认参数，每次调用使用的都是初始化的值。
```python
 def immutable_test(i=1):
    print('before operation, address of i', id(i))
    # i是不可变对象， 对它重新赋值，其实是重新创建对象，然后将变量名x绑定到新对象上。 但是： 函数定义时默认参数x赋予的地址所指向的地址没变，指向的值还是1
    i += 1
    print('after operation, address of i', id(i))
    return i

print(immutable_test())
print(immutable_test())

```
输出：
```
before operation, address of i 4333502704
after operation, address of i 4333502736
2
before operation, address of i 4333502704
after operation, address of i 4333502736
2
```

### 避坑
`不可变的默认参数`的多次调用不会造成任何影响(符合预期），`可变默认参数`的多次调用的结果不符合预期。那么在使用可变默认参数时，就不能只在函数定义时初始化一次，而应该在每次调用时初始化。

最佳实践是定义函数时指定**可变默认参数的值为None**，**在函数体内部重新绑定默认参数的值**。以下是对上面的两个可变默认参数示例最佳实践的应用：

```python
def good_append(new_item, a_list=None):
    if a_list is None:  # 定义函数时指定可变默认参数的值为None，在函数体内部重新绑定默认参数的值
        a_list = []
    a_list.append(new_item)
    return a_list

print(good_append('1'))                   # ['1']
print(good_append('2'))                   # ['2']
print(good_append('c', ['a', 'b']))       # ['a', 'b', 'c']
```

